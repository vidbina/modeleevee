# Modeleevee

A novice's attempt at creating a gem to deal with a couple of tricks I'd love my Models to know.

## Installation

Add this line to your application's Gemfile:

    gem 'modeleevee', '~> 0.1'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install modeleevee

## Usage

The Modeleevee module extends ActiveRecord models to deal with binary ids and can be put to work for you by simply including the module into your model.

```ruby
class Pizza extend ActiveRecord::Base
  include Modeleevee

  attr_accessible :topping

	# do something
  # perhaps bake the pizza, sell the pizza, wrap the pizza as a gift
  # or...  eat the pizza -- after baking it of course ;)
end
```

Modeleevee extends the module to hijack the entire id generation process. Normally ActiveRecord modules determine the next integer id by incrementing the value of the last generated id. Modeleevee, however; generates a random binary id upon saving the model to the database.

```ruby
# let's make a simple pizza
boring_pizza = Pizza(:topping => "cheese").new
# store pizza for later use
boring_pizza.save
```

Modeleevee awakes whenever the `save` call is made. It basically checks the model for validity, generates a unique id and saves the model and newfound identity to the database and it does so exactly in this order. If any of the steps fail the entire ritual will be brought to a halt. Meaning that generation of an id would not even be attempted if the model doesn't check out as a valid entity.

## Generation of Ids

The binary id's are generated by running a digest on two values -- the current time and the description of the object which is acquired by calling `seed_which`.

```ruby
# this is how Modeleevee gets a possible new id
def digest
  Digest::MD5.hexdigest(seed_which + seed_time)
end
```

The time will often enough lead to unique values but as you've already suspected you'd be in some trouble if multiple users attempted to save a pizza at the exact same time. The `seed_which` method increases the enthropy of id generation by involving a string representation of the model in the id-generation process. You are free to overload the `seed_which` method at any time but please do so considering the best options for minng unique values. By default `seed_which` will return something like `#<Pizza:0xa8e08b4>` for our pizza which contains the object identifier that is assigned by the Ruby interpreter. All of a sudden there are more forces (interpreter uptime, allocated memory and history, among many other forces) at work to generate that "unique" id.

Overloading `seed_which` to return data based on some model properties would not always leave you with unique results as I could suspect that there will be multiple curious fellas and gals attempting to make pizzas with mashmallow toppings, but you're free to do so anyway. This would be useful if you have overloaded the `to_s` method of you model's instance to return something that isn't really unique but I doubt that you would do something that odd.

```ruby
def seed_which
  # instead of the default self.to_s which returns "surprise" everytime
  # since I chose to overload the to_s method. *evil laugh*
  "#{self.topping}"
end
```

However, in many cases overloading `seed_which` to return something other than the default `self.to_s` in combination with the output to the `seed_time` call will return some pretty unique output when fed to `self.digest`.

### If the Id Already Exists?
In the highly unlikely event that the proposed generated id already exists, we will just retry the generation process. In the default implementation this will mean that the `seed_time` output fed to the `digest` method changes while the result of the `seed_which` call remains the same. This seems fair. As we're still dealing with the same entity I don't see a direct need to design `seed_which` to return unique data at every call. Again, if you wish to have Modeleevee dance to a different tune please overload the `seed_which` method.

### Loop Till the End of Time...
It should be noted that Modeleevee could possibly get stuck in a infinite loop if many ids alreay exist. This would be realistic risk to ponder about if you're keeping a database of every cellestial body mankind discovers.

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Added some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request
